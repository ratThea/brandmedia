/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_thea_tabs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/thea-tabs.js */ \"./src/js/modules/thea-tabs.js\");\n/* harmony import */ var _modules_thea_slider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/thea-slider.js */ \"./src/js/modules/thea-slider.js\");\n/* harmony import */ var _modules_functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/functions.js */ \"./src/js/modules/functions.js\");\n\r\n\r\n\r\n\r\n\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\", () => {\r\n\r\n    // Установка яндекс карты (если она есть):\r\n    if(document.body.hasAttribute(\"data-map\")) {\r\n        ymaps.ready(_modules_functions_js__WEBPACK_IMPORTED_MODULE_2__.init.bind(null, 37.83425076906181, -85.76824150000002, 7));\r\n    }\r\n\r\n    document.documentElement.addEventListener(\"click\", ({ target }) => {\r\n\r\n        // Обработка popup окна, если клик был по элементу \"image-popup\":\r\n        if(target.dataset.action === \"image-popup\") {\r\n            _modules_functions_js__WEBPACK_IMPORTED_MODULE_2__.imagePopup(target);\r\n            return;\r\n        }\r\n\r\n        // Скрытие/показ навигации слайдера на главной странице при клике на экран:\r\n        if(target.closest(\".slider__screen-wrapper\")) {\r\n            _modules_functions_js__WEBPACK_IMPORTED_MODULE_2__.toggleElement( document.getElementById(\"presentation-slider-nav\"), \"active\" )\r\n        }\r\n\r\n        // Обработчик скрытия/показа навигации в шапке (синхрозинировано с медиазапросом \"sm\"):\r\n        if(document.documentElement.clientWidth <= 770) {\r\n            _modules_functions_js__WEBPACK_IMPORTED_MODULE_2__.toggleNavigation();\r\n        }\r\n    });\r\n\r\n    // Все табы на сайте:\r\n    const recentActivityTabs = new _modules_thea_tabs_js__WEBPACK_IMPORTED_MODULE_0__.TheaTabs({ root: document.getElementById(\"recent-activity\") }),\r\n          portfolioTabs      = new _modules_thea_tabs_js__WEBPACK_IMPORTED_MODULE_0__.TheaTabs({ root: document.getElementById(\"portfolio-tabs\"), startActive: 3, equalify: false }),\r\n          aboutTabs          = new _modules_thea_tabs_js__WEBPACK_IMPORTED_MODULE_0__.TheaTabs({ root: document.getElementById(\"about-tabs\") })\r\n\r\n    // Слайдер на главной странице (index.html):\r\n    const presentationSlider = new _modules_thea_slider_js__WEBPACK_IMPORTED_MODULE_1__.TheaSlider({\r\n        root: document.getElementById(\"presentation-slider\"),\r\n        speed: 1.5,\r\n        autoplay: true,\r\n        draggable: false,\r\n        controls: {\r\n            buttons: {\r\n                prev: document.getElementById(\"presentation-slider-prev\"),\r\n                next: document.getElementById(\"presentation-slider-next\"),\r\n                toggle: document.getElementById(\"presentation-slider-toggle\")\r\n            },\r\n            dots: {\r\n                container: document.getElementById(\"presentation-slider-dots\"),\r\n                dotClass: \"slider__dot\"\r\n            }\r\n        }\r\n    });\r\n\r\n    // Слайдер на странице \"Portfolio\" (portfolio.html):\r\n    const portfolioSlider = new _modules_thea_slider_js__WEBPACK_IMPORTED_MODULE_1__.TheaSlider({\r\n        root: document.getElementById(\"portfolio-slider\"),\r\n        controls: {\r\n            dots: {\r\n                container: document.getElementById(\"portfolio-slider-dots\"),\r\n                dotClass: \"slider__dot\"\r\n            }\r\n        }\r\n    });\r\n\r\n});\n\n//# sourceURL=webpack://gulp_starter/./src/js/main.js?");

/***/ }),

/***/ "./src/js/modules/functions.js":
/*!*************************************!*\
  !*** ./src/js/modules/functions.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createDOMElement\": () => (/* binding */ createDOMElement),\n/* harmony export */   \"imagePopup\": () => (/* binding */ imagePopup),\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"toggleElement\": () => (/* binding */ toggleElement),\n/* harmony export */   \"toggleNavigation\": () => (/* binding */ toggleNavigation)\n/* harmony export */ });\n\r\n\r\n/**\r\n * Скрывает/показывает модальное pop-up окно с картинкой, у которой есть потомок с data-action=\"image-popup\".\r\n * @param {HTMLElement} trigger Кнопка, которая активирует pop-up.\r\n */\r\nfunction imagePopup(trigger) {\r\n\r\n    const image     = trigger.parentElement.querySelector(\"img\"),\r\n          imageData = {\r\n            src: image.src,\r\n            description: image.dataset.description || \"Описание картинки (надо заполнить)\"\r\n          };\r\n\r\n    const scrollBarWidth     = window.innerWidth - document.documentElement.clientWidth;\r\n    const overlay            = createDOMElement({ classes: \"popup-overlay\", css: { \"padding-top\": 1, \"width\":  `${ document.documentElement.clientWidth + scrollBarWidth }px`, top: `${ document.documentElement.scrollTop }px` } }),\r\n          overlayContent     = createDOMElement({ tagName: \"div\", classes: \"popup-overlay__content\", content: { data: `<img class=\"popup-overlay__image\" src=\"${imageData.src}\"><div class=\"popup-overlay__text\">${ imageData.description }</div>` } }),\r\n          overlayCloseButton = createDOMElement({ tagName: \"span\", classes: \"popup-overlay__close-button\" });\r\n\r\n    overlay.append(overlayContent);\r\n    overlayContent.append(overlayCloseButton);\r\n\r\n    document.body.prepend(overlay);\r\n    // Запрет прокрутки:\r\n    document.body.style.overflow = \"hidden\";\r\n    document.body.style.paddingRight = `${ scrollBarWidth }px`;\r\n\r\n    overlayCloseButton.addEventListener(\"click\", removeOverlay);\r\n\r\n    /**\r\n     * Удаляет overlay, вместе со всем его содержимым и обработчиком события.\r\n     */\r\n    function removeOverlay() {\r\n        overlayCloseButton.removeEventListener(\"click\", removeOverlay);\r\n        overlay.remove();\r\n        // Возврат прокрутки:\r\n        document.body.style.overflow = \"\";\r\n        document.body.style.paddingRight = `0`;\r\n    }\r\n}\r\n\r\n/**\r\n * Создает DOM-элемент с указанными классами, стилями и содержимым. На страницу не добавляет, только возвращает его.\r\n * @param {String} tagName Имя тега\r\n * @param {String|Array} classes Классы: строка или массив строк\r\n * @param {Object} css Объект со свойствами вида { name: value }. Все свойства с \"-\" будут преобразованы в camelCase\r\n * @param {Object} content Объект вида { position, data }. data может быть строкой с html кодом или другим DOM-элементом\r\n * @returns {HTMLElement}\r\n */\r\nfunction createDOMElement({ tagName = \"div\", classes = \"\", css = null, content = null }) {\r\n\r\n    const element = document.createElement(tagName);\r\n\r\n    if(classes.length) {\r\n        element.className = Array.isArray(classes) ? classes.filter(item => typeof item === \"string\").join(\" \") : classes;\r\n    }\r\n\r\n    if(css) {\r\n        for(const [ name, value ] of Object.entries(css)) {\r\n            let propName = name;\r\n\r\n            if(name.includes(\"-\")) {\r\n                propName = name.split(\"-\")\r\n                               .map((item, index) => index === 0 ? item.toLocaleLowerCase() : item[0].toUpperCase() + item.slice(1))\r\n                               .join(\"\");\r\n            }\r\n\r\n            element.style[propName] = value;\r\n        }\r\n    }\r\n\r\n    if(content) {\r\n        const { position = \"afterbegin\", data } = content,\r\n              method = (typeof data === \"string\") ? \"insertAdjacentHTML\" : \"insertAdjacentElement\";\r\n        element[method](position, data);\r\n    }\r\n\r\n    return element;\r\n}\r\n\r\n/**\r\n * Переключает атрибут у элемента. Это может быть либо класс или классы, либо атрибут.\r\n * @param {HTMLElement} target Элемент, у которого надо переключать атрибут\r\n * @param {String|Object} param Атрибут, который надо переключить. Если это класс, писать \"class\" или \"class1 class2\". Если атрибут - { name, on, of }\r\n */\r\nfunction toggleElement(target, param) {\r\n\r\n    if(!param) {\r\n        target.hidden = !target.hidden;\r\n        return;\r\n    }\r\n\r\n    if(typeof param === \"string\") {\r\n        const data = param.trim();\r\n\r\n        if(data.includes(\" \")) {\r\n            const classes = data.split(\" \") ;\r\n            for(const className of classes) {\r\n                target.classList.contains(className) ?  target.classList.remove(className) : target.classList.add(className);\r\n            }\r\n            return;\r\n        }\r\n\r\n        target.classList.contains(data) ?  target.classList.remove(data) : target.classList.add(data);\r\n    }\r\n\r\n    if(typeof param === \"object\") {\r\n        const { name, on, off } = param;\r\n        if(target.hasAttribute(name)) {\r\n            target.getAttribute(name) === on ? target.setAttribute(name, off) : target.setAttribute(name, on);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Скрывает/показывает меню и подменю в шапке. Назначается слушателем по клику на документ, так как работает только\r\n * на маленьких экрана и надо обрабатывать клик в \"пустоту\", чтобы скрыть все активные меню.\r\n * Только для этого проекта (brandmedia).\r\n */\r\nfunction toggleNavigation() {\r\n    const toggler                = window.event.target.closest(\"[data-action]\"),\r\n          mainMenu               = document.getElementById(\"header-menu\"),\r\n          submenuContainers      = Array.from(mainMenu.children[0].children),\r\n          activeSubmenuIndex     = submenuContainers.findIndex(container => container.classList.contains(\"active\"));\r\n\r\n    // Если клик был по элементу с data-action\r\n    if(toggler) {\r\n\r\n        const action = toggler.dataset.action;\r\n\r\n        // Скрывает/показывает главное меню, и прячет подменю, если оно открыто.\r\n        if(action === \"main\") {\r\n            toggleElement(mainMenu, \"active\");\r\n            if(activeSubmenuIndex !== -1) {\r\n                submenuContainers[activeSubmenuIndex].classList.remove(\"active\");\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Скрывает/показывает подменю текущего пунтка. Если уже есть другое открытое меню, скрывает его\r\n        // и предотвращает переход по ссылке.\r\n        if(action === \"submenu\") {\r\n\r\n            window.event.preventDefault();\r\n            const clickedIndex = submenuContainers.findIndex(container => container === toggler.parentElement.parentElement);\r\n\r\n            if(activeSubmenuIndex !== -1) {\r\n                submenuContainers[activeSubmenuIndex].classList.remove(\"active\");\r\n            }\r\n            if(clickedIndex !== activeSubmenuIndex) {\r\n                toggleElement(submenuContainers[clickedIndex], \"active\");\r\n            }\r\n            return;\r\n        }\r\n    }\r\n\r\n    // Если клика был в \"пустоту\", скрыть все: и главное меню и подменю.\r\n    mainMenu.classList.remove(\"active\");\r\n    if(activeSubmenuIndex !== -1) submenuContainers[activeSubmenuIndex].classList.remove(\"active\");\r\n}\r\n\r\n/**\r\n * Вызывает интекартивную Яндекс.Карту с указанным адресом (по умолчанию штат Кентуки, США - взят из макета).\r\n * @param {Number} latitude Широта\r\n * @param {Number} longitude Долгота\r\n * @param {Number} zoom Масштаб\r\n */\r\nfunction init(latitude, longitude, zoom) {\r\n    const map =  new ymaps.Map(\"brandmedia-contact-map\", { center: [ latitude, longitude ], zoom: zoom });\r\n\r\n    map.controls.remove(\"geolocationControl\");\r\n    map.controls.remove(\"searchControl\");\r\n    map.controls.remove(\"trafficControl\");\r\n    map.controls.remove(\"typeSelector\");\r\n    map.controls.remove(\"fullscreenControl\");\r\n    map.controls.remove(\"zoomControl\");\r\n    map.controls.remove(\"rulerControl\");\r\n    map.behaviors.disable([\"scrollZoom\"]);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://gulp_starter/./src/js/modules/functions.js?");

/***/ }),

/***/ "./src/js/modules/thea-slider.js":
/*!***************************************!*\
  !*** ./src/js/modules/thea-slider.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TheaSlider\": () => (/* binding */ TheaSlider)\n/* harmony export */ });\n\r\n\r\n/**\r\n * Класс-конструктор компонента \"слайдер\", рассчитан на один текущий активный слайд. Работает вместе с файлом стилей \"thea-slider.scss\".\r\n */\r\nclass TheaSlider {\r\n    /**\r\n     * @param {HTMLElement} root Корневой html-элемент слайдера (родительский для всех слайдов). Обязательный параметр\r\n     * @param {Object} controls Объект с настройками элементов управления. Обязательный параметр\r\n     * @param {Number} startActive Индекс первого активного слайда\r\n     * @param {Number} speed Скорость перелистывания (в секундах)\r\n     * @param {Boolean} infinite Если true, слайдер будет бесконечным\r\n     * @param {Boolean} autoplay Включить по умолчанию\r\n     * @param {Boolean} draggable Если true, слайды можно будет перетаскивать мышкой\r\n     */\r\n    constructor({ root, controls, startActive = 0, speed = 1, infinite = true, autoplay = true, draggable = true }) {\r\n        if (root && root.children.length && controls) {\r\n\r\n            this._setupBase(root, controls, startActive, speed, infinite, autoplay, draggable);\r\n            this._setupControls();\r\n            this._setupHandlers();\r\n\r\n            if(autoplay) this._autoplay();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Базовые классы, необходимые для работы слайдера (описаны в файле стилей \"thea-slider.scss\").\r\n     * @private\r\n     */\r\n    _prefixClass = \"thea-slider\";\r\n    _baseClasses = {\r\n        root: this._prefixClass,\r\n        container: `${ this._prefixClass }__container`,\r\n        slide: `${ this._prefixClass }__slide`,\r\n        controls: {\r\n            dots: {\r\n                container: `${ this._prefixClass }__dots`,\r\n                dot: `${ this._prefixClass }__dot`\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Устанавливает настройки в объекте \"this._config\". Все параметры дублируют конструктор.\r\n     * @param {Object} controls\r\n     * @param {Number} startActive\r\n     * @param {Number} speed\r\n     * @param {Boolean} infinite\r\n     * @param {Boolean} autoplay\r\n     * @param {Boolean} draggable\r\n     * @private\r\n     */\r\n    _configure(controls, startActive, speed, infinite, autoplay, draggable) {\r\n        this._config = {};\r\n\r\n        const baseWidth       = this._root.offsetWidth,\r\n            baseHeight      = this._root.offsetHeight,\r\n            baseLength      = this._slides.items.length,\r\n            transitionSpeed = speed * 1000;\r\n\r\n        this._config.slide = {\r\n            width: baseWidth,\r\n            height: baseHeight,\r\n            count: baseLength,\r\n            lastIndex: baseLength - 1,\r\n            activeIndex: startActive\r\n        };\r\n\r\n        this._config.offset = {\r\n            left: -baseWidth * (infinite ? (startActive + 1) : startActive),\r\n            width: baseWidth,\r\n            min:  -baseWidth * (infinite ? (startActive + 1) : startActive),\r\n            max:  -baseWidth * baseLength,\r\n            speed: transitionSpeed\r\n        };\r\n\r\n        this._config.settings = {\r\n            state: {\r\n                status: autoplay ? \"active\" : \"paused\", // \"active\" или \"paused\"\r\n                cooldown: !autoplay\r\n            },\r\n            autoplay: {\r\n                isSet: autoplay,\r\n                timerId: null\r\n            },\r\n            infinite: infinite,\r\n            transition: `left ${ speed }s ease`,\r\n            draggable: {\r\n                isSet: draggable,\r\n                startDragPosition: 0,\r\n                dragRequiredOffset: 25\r\n            }\r\n        };\r\n\r\n        this._config.controls = {\r\n            buttons: {\r\n                isSet: (\"buttons\" in controls),\r\n            },\r\n            dots: {\r\n                isSet: (\"dots\" in controls),\r\n            }\r\n        };\r\n\r\n        if(this._config.controls.buttons.isSet) {\r\n            this._config.controls.buttons.prev = controls.buttons.prev;\r\n            this._config.controls.buttons.next = controls.buttons.next;\r\n            this._config.controls.buttons.toggle = controls.buttons.toggle;\r\n        }\r\n\r\n        if(this._config.controls.dots.isSet) {\r\n            this._config.controls.dots.container = controls.dots.container;\r\n            this._config.controls.dots.dotClass = controls.dots.dotClass;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Устанавливает базовую разметку, стили и классы. Вызывает \"_configure\", \"_setupBaseStyles\". Параметры дублируют конструктор.\r\n     * @param {HTMLElement} root\r\n     * @param {Object} controls\r\n     * @param {Number} startActive\r\n     * @param {Number} speed\r\n     * @param {Boolean} infinite\r\n     * @param {Boolean} autoplay\r\n     * @param {Boolean} draggable\r\n     * @private\r\n     */\r\n    _setupBase(root, controls, startActive, speed, infinite, autoplay, draggable) {\r\n        this._root = root;\r\n        this._slides = { items: Array.from(this._root.children) };\r\n\r\n        this._configure(controls, startActive, speed, infinite, autoplay, draggable);\r\n\r\n        if(infinite) {\r\n            this._slides.before = this._slides.items[this._slides.items.length - 1].cloneNode(true);\r\n            this._slides.after = this._slides.items[0].cloneNode(true);\r\n        }\r\n\r\n        this._container = document.createElement(\"div\");\r\n        this._root.append(this._container);\r\n        (infinite) ? this._container.append(this._slides.before, ...this._slides.items, this._slides.after) : this._container.append(...this._slides.items);\r\n\r\n        this._setupBaseStyles();\r\n\r\n        this._container.style.left = `${ this._config.offset.left }px`;\r\n        this._slides.items[ this._config.slide.activeIndex ].classList.add(\"active\");\r\n    }\r\n\r\n    /**\r\n     * Устанавливает базовые css-классы и стили.\r\n     * @private\r\n     */\r\n    _setupBaseStyles() {\r\n        this._root.classList.add(this._baseClasses.root);\r\n        this._container.classList.add(this._baseClasses.container);\r\n        this._container.style.transition = this._config.settings.transition;\r\n\r\n        this._slides.items.forEach(slideItem => {\r\n            slideItem.classList.add(this._baseClasses.slide);\r\n            slideItem.style.width = `${ this._config.slide.width }px`;\r\n            slideItem.style.height = `${ this._config.slide.height }px`;\r\n        });\r\n\r\n        if(this._config.settings.infinite) {\r\n\r\n            const mainSlideClass = this._slides.items[0].className;\r\n\r\n            this._slides.before.className = `${ this._baseClasses.slide } ${ mainSlideClass } clone-last`;\r\n            this._slides.after.className  = `${ this._baseClasses.slide } ${ mainSlideClass } clone-first`;\r\n\r\n            this._slides.before.style.width = `${ this._config.slide.width }px`;\r\n            this._slides.after.style.width  = `${ this._config.slide.width }px`;\r\n\r\n            this._slides.before.style.height = `${ this._config.slide.height }px`;\r\n            this._slides.after.style.height  = `${ this._config.slide.height }px`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Усталавливает элементы управления (или точки, или кнопки, или и то и другое).\r\n     * @private\r\n     */\r\n    _setupControls() {\r\n        if(this._config.controls.buttons.isSet && this._config.controls.buttons.toggle) {\r\n            const { toggle } = this._config.controls.buttons;\r\n            toggle.dataset.status = this._config.settings.state.status;\r\n        }\r\n\r\n\r\n        if(this._config.controls.dots.isSet) {\r\n            const { container, dotClass } = this._config.controls.dots;\r\n            const dotElements = [];\r\n\r\n            container.classList.add(this._baseClasses.controls.dots.container);\r\n\r\n            for(let point = 0; point < this._config.slide.count; point++) {\r\n                const dotElement = document.createElement(\"span\");\r\n                dotElement.className = `${ this._baseClasses.controls.dots.dot } ${ dotClass }`;\r\n                dotElement.dataset.point  = `${ point }`;\r\n                dotElements.push(dotElement);\r\n            }\r\n\r\n            dotElements[this._config.slide.activeIndex].classList.add(\"active\");\r\n            this._dots = dotElements;\r\n            container.append(...dotElements);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Устанавливает обработчики события клика по элементам управления, какие были установлены или возможность перетаскивать слайды.\r\n     * @private\r\n     */\r\n    _setupHandlers() {\r\n\r\n        if(this._config.controls.buttons.isSet) {\r\n            const { prev, next, toggle } = this._config.controls.buttons;\r\n            prev.addEventListener(\"click\",  this.prev.bind(this));\r\n            next.addEventListener(\"click\",  this.next.bind(this));\r\n            if(toggle) {\r\n                toggle.addEventListener(\"click\",  this.toggle.bind(this));\r\n            }\r\n        }\r\n\r\n        if(this._config.controls.dots.isSet) {\r\n            this._config.controls.dots.container.addEventListener(\"click\", event => {\r\n                event.stopPropagation();\r\n                const dotElement = event.target.closest(\"[data-point]\");\r\n                if(dotElement) {\r\n                    const data = {\r\n                        type: dotElement.dataset.action = \"scroll\",\r\n                        index: +dotElement.dataset.point\r\n                    };\r\n                    this._slide.bind(this, data)();\r\n                }\r\n            });\r\n        }\r\n\r\n        if(this._config.settings.draggable.isSet) {\r\n            this._container.addEventListener(\"mousedown\", event => {\r\n                // Подготовка к перетаскиванию:\r\n                event.preventDefault(); // Отключение \"dragstart\" по умолчанию.\r\n                event.stopPropagation();\r\n                this._container.classList.add(\"being-dragged\");\r\n                this._config.settings.draggable.startDragPosition = event.pageX;\r\n\r\n                // Обработка события движения мыши:\r\n                const moveHandler = this._dragSlide.bind(this);\r\n                this._container.addEventListener(\"mousemove\", moveHandler)\r\n\r\n                // Возврат в исходное состояние:\r\n                this._container.onmouseup = () => {\r\n                    document.removeEventListener(\"mousemove\", moveHandler);\r\n                    this._container.classList.remove(\"being-dragged\");\r\n                    this._config.settings.draggable.startDragPosition = 0;\r\n                    this._container.onmouseup = null;\r\n                }\r\n            });\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Перетаскивает слайд на один впреред или назад, в зависимости от координат курсора, относительно координат в момент клика.\r\n     * @param {Number} pageX Координаы курсора во время перетаскивания (берется из event). Вызывается толко в обработчике \"mousemove\".\r\n     * @private\r\n     */\r\n    _dragSlide({ pageX }) {\r\n        const difference = pageX - this._config.settings.draggable.startDragPosition;\r\n        if(Math.abs(difference) >= this._config.settings.draggable.dragRequiredOffset) {\r\n            this._slide.bind(this, { type: difference < 0 ? \"prev\" : \"next\" })();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Переключает актинвый слайд (деактивирует последний актинвый и включает новый, который был активирован)\r\n     * @param activate\r\n     * @private\r\n     */\r\n    _toggleActiveSlide(activate = true) {\r\n        const action = activate ? \"add\" : \"remove\";\r\n        this._slides.items[this._config.slide.activeIndex].classList[action](\"active\");\r\n        if(this._config.controls.dots.isSet) {\r\n            this._dots[this._config.slide.activeIndex].classList[action](\"active\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Проверяет, можно ли выполнить действие - сдвинуть слайды каким либо образом.\r\n     * @param {String} type Тип действия (prev/next/scroll)\r\n     * @param {Number} index Индекс слайда, который надо сделать актинвым (указывается только при type = \"scroll\")\r\n     * @param {Boolean} autoplay Вызван ли метод slide через метод _autoplay (указывается только в нем)\r\n     * @private\r\n     */\r\n    _able({ type, index = null, autoplay = false }) {\r\n\r\n        if(autoplay && this._config.settings.state.status === \"paused\") return false;\r\n\r\n        if(!this._config.settings.state.cooldown) {\r\n\r\n            if(type === \"prev\") {\r\n                return (this._config.slide.activeIndex - 1 >= 0 && !this._config.settings.infinite) || this._config.settings.infinite;\r\n            }\r\n\r\n            if(type === \"next\") {\r\n                return (this._config.slide.activeIndex + 1 <= this._config.slide.lastIndex && !this._config.settings.infinite) || this._config.settings.infinite;\r\n            }\r\n\r\n            if(type === \"scroll\") {\r\n                return index !== this._config.slide.activeIndex;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Запускает слайдер, как только объект будет создан и настроен.\r\n     * @private\r\n     */\r\n    _autoplay() {\r\n        this._config.settings.autoplay.timerId = setInterval(this._slide.bind(this, { type: \"next\", autoplay: true }), this._config.offset.speed);\r\n    }\r\n\r\n    /**\r\n     * Ставит на паузу или возобновляет работу слайдера. Меняет флаг \"this._config.settings.state.status\" с \"active\" на \"paused\" и наоборот.\r\n     * @private\r\n     */\r\n    _togglePause() {\r\n        const status = this._config.settings.state.status === \"active\" ? \"paused\" : \"active\";\r\n        this._config.settings.state.status = status;\r\n        if(this._config.controls.buttons.toggle) {\r\n            this._config.controls.buttons.toggle.dataset.status = status;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Перескакивает с последнего на первый элемент или наоборот, делая слайдер бесконечным.\r\n     * @param {String} type\r\n     * @private\r\n     */\r\n    _loopSlider(type) {\r\n\r\n        const loopData = {\r\n            clonePosition:  (type === \"prev\") ? this._config.offset.left += this._config.offset.width : this._config.offset.left -= this._config.offset.width,\r\n            hiddenOffset:   (type === \"prev\") ? this._config.offset.max : -this._config.offset.width,\r\n            newActiveIndex: (type === \"prev\") ? this._config.slide.lastIndex : 0\r\n        };\r\n\r\n        this._container.style.left = `${ loopData.clonePosition }px`;\r\n\r\n        setTimeout(() => {\r\n            this._container.style.transition = \"none\";\r\n            this._config.offset.left = loopData.hiddenOffset;\r\n            this._container.style.left = `${ this._config.offset.left }px`;\r\n\r\n            this._config.slide.activeIndex = loopData.newActiveIndex;\r\n            this._toggleActiveSlide();\r\n\r\n            setTimeout(() => {\r\n                this._container.style.transition = this._config.settings.transition;\r\n                this._config.settings.state.cooldown = false;\r\n            }, this._config.offset.speed / 100);\r\n\r\n        }, this._config.offset.speed);\r\n    }\r\n\r\n    /**\r\n     * Выполняет сдвиг слайдера, в зависимости от переданного действия.\r\n     * @param {String} type Тип действия (prev/next/scroll)\r\n     * @param {Number} index Индекс слайда, который надо сделать актинвым (указывается только при type = \"scroll\")\r\n     * @param {Boolean} autoplay Вызван ли метод slide через метод _autoplay (указывается только в нем)\r\n     * @private\r\n     */\r\n    _slide({ type, index = null, autoplay = false}) {\r\n        if(this._able({ type, index, autoplay })) {\r\n            this._config.settings.state.cooldown = true;\r\n            this._toggleActiveSlide(false);\r\n\r\n            if(type === \"prev\") {\r\n                if(this._config.slide.activeIndex - 1 < 0) {\r\n                    this._loopSlider(type);\r\n                    return;\r\n                }\r\n\r\n                this._config.offset.left += this._config.offset.width;\r\n                this._config.slide.activeIndex--;\r\n            }\r\n\r\n            if(type === \"next\") {\r\n                if(this._config.slide.activeIndex + 1 > this._config.slide.lastIndex) {\r\n                    this._loopSlider(type);\r\n                    return;\r\n                }\r\n\r\n                this._config.offset.left -= this._config.offset.width;\r\n                this._config.slide.activeIndex++;\r\n            }\r\n\r\n            if(type === \"scroll\") {\r\n                this._config.offset.left = -this._config.offset.width * ( this._config.settings.infinite ? index + 1 : index );\r\n                this._config.slide.activeIndex = index;\r\n            }\r\n\r\n            this._container.style.left = `${ this._config.offset.left }px`;\r\n            this._toggleActiveSlide();\r\n            setTimeout(() => this._config.settings.state.cooldown = false, this._config.offset.speed);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Переход к предыдущему слайду.\r\n     */\r\n    prev() {\r\n        window.event.stopPropagation();\r\n        this._slide({ type: \"prev\" });\r\n    }\r\n\r\n    /**\r\n     * Переход к следующему слайду.\r\n     */\r\n    next() {\r\n        window.event.stopPropagation();\r\n        this._slide({ type: \"next\" });\r\n    }\r\n\r\n    /**\r\n     * Ставит на паузу или возобновляет работу слайдера.\r\n     */\r\n    toggle() {\r\n        window.event.stopPropagation();\r\n        this._togglePause();\r\n        this._autoplay();\r\n    }\r\n}\n\n//# sourceURL=webpack://gulp_starter/./src/js/modules/thea-slider.js?");

/***/ }),

/***/ "./src/js/modules/thea-tabs.js":
/*!*************************************!*\
  !*** ./src/js/modules/thea-tabs.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TheaTabs\": () => (/* binding */ TheaTabs)\n/* harmony export */ });\n\r\n\r\n/**\r\n * Создает компонент \"Табы\" (вкладки, переключающие контент). Требует необходимой разметки.\r\n * Рабоает вместе с файлом стилей \"thea.tabs.scss\".\r\n */\r\nclass TheaTabs {\r\n  /**\r\n   * @param {Object} root Корневой html-элемент вкладок\r\n   * @param {Number} startActive Индекс первого активной вкладки\r\n   * @param {Boolean} equalify Если true, установит всем вкладкам одинаковую высоту\r\n   */\r\n  constructor({ root, startActive = 0, equalify = true }) {\r\n    if(root) {\r\n      this._setupBase(root, startActive, equalify);\r\n      this._setupHandler();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Базовые классы, необходимые для работы вкладок (описаны в файле стилей \"thea-tabs.scss\").\r\n   * @private\r\n   */\r\n  _name = \"thea-tabs\";\r\n  _baseClasses = {\r\n    root: this._name,\r\n    header: `${ this._name }__header`,\r\n    body: `${ this._name }__body`,\r\n    button: `${ this._name }__button`,\r\n    content: `${ this._name }__content`\r\n  };\r\n\r\n  /**\r\n   * Установка базовой html-размеки, добавление необходимых css-классов и стилей.\r\n   * @param {Object} root\r\n   * @param {Number} startActive\r\n   * @param {Boolean} equalify\r\n   * @private\r\n   */\r\n  _setupBase(root, startActive, equalify) {\r\n    this._root = root;\r\n    this._buttons = Array.from(this._root.children[0].children);\r\n    this._contents = Array.from(this._root.children[1].children);\r\n\r\n    this._configure(startActive, equalify);\r\n\r\n    this._root.classList.add(this._baseClasses.root);\r\n    this._root.children[0].classList.add(this._baseClasses.header);\r\n    this._root.children[1].classList.add(this._baseClasses.body);\r\n\r\n    if(this._buttons.length === this._contents.length) {\r\n      this._buttons.forEach((button, index) => {\r\n        button.classList.add(this._baseClasses.button);\r\n        button.dataset.point = `${ index }`;\r\n        this._contents[index].classList.add(this._baseClasses.content);\r\n      });\r\n    }\r\n\r\n    this._buttons[this._config.params.activeTab].classList.add(\"active\");\r\n    this._contents[this._config.params.activeTab].classList.add(\"active\");\r\n\r\n    if(this._config.params.equalify) this._equalifyHeights();\r\n  }\r\n\r\n  /**\r\n   * Создание и (или) настройка элементов управления вкладками.\r\n   * @param {Number} startActive\r\n   * @param {Boolean} equalify\r\n   * @private\r\n   */\r\n  _configure(startActive, equalify) {\r\n    this._config = {};\r\n\r\n    if(equalify) {\r\n      this._config.tabContent = {\r\n        maxHeight: Math.max(...this._contents.map(item => item.offsetHeight)),\r\n      };\r\n    }\r\n\r\n    this._config.params = {\r\n      equalify: equalify,\r\n      activeTab: startActive\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Устанавливает обработчк на табы.\r\n   * @private\r\n   */\r\n  _setupHandler() {\r\n    this._root.addEventListener(\"click\", event => {\r\n      const button = event.target.closest(`[data-point]`);\r\n\r\n      if(button) {\r\n        const activateIndex = +button.dataset.point;\r\n        if(activateIndex !== this._config.params.activeTab) {\r\n          this._toggleActive(activateIndex);\r\n        }\r\n      }\r\n\r\n    });\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Number} index Индекс вкладки, которую надо активировать\r\n   * @private\r\n   */\r\n  _toggleActive(index) {\r\n    this._buttons[this._config.params.activeTab].classList.remove(\"active\");\r\n    this._contents[this._config.params.activeTab].classList.remove(\"active\");\r\n\r\n    this._buttons[index].classList.add(\"active\");\r\n    this._contents[index].classList.add(\"active\");\r\n\r\n    this._config.params.activeTab = index;\r\n  }\r\n\r\n  /**\r\n   * Устанавливает содержимым всех вкладок одинаковую высоту.\r\n   * @private\r\n   */\r\n  _equalifyHeights() {\r\n    this._contents.forEach(tabContent => tabContent.style.height = `${ this._config.tabContent.maxHeight }px`);\r\n  }\r\n\r\n}\n\n//# sourceURL=webpack://gulp_starter/./src/js/modules/thea-tabs.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/main.js");
/******/ 	
/******/ })()
;